Day01
正课：
1、什么是js,如何编写、调试js
2、***变量
3、***数据类型


1、什么是js：
   前端三大语言：
   HTML：专门编写网页内容的语言
   CSS：专门美化网页内容样式的语言

++++++++++++++++++++++++++++++++++++++++++++++++++
   交互：用户操作  程序处理或响应操作  返回结果
   JavaScript：专门编写交互程序的语言

                运行于js解释器/引擎中
		解释执行----逐行读取，先读到先执行，后读到后执行

		
  js发展史：
  Netscape:navigator
     1995   JavaScript----像极了Java，但比Java简单
            Java"write once run anywhere"
     1996   JavaScript 1.1-->ECMA

  *ECMAScript标准-->定义了js语言的核心语法
    Netscript-->遵照标准，实现了Javascript语言
    Microsoft-->遵照标准，实现了JScript语言

  W3C：DOM标准-->专门操作网页内容的标准
       所有浏览器都兼容的标准

  BOM：专门操作浏览器窗口的编程接口

  *js=ECMAScript标准+DOM标准+BOM


  2004 Netscript-->Mozillz

 2、如何使用js:
     如何运行：2种：1、浏览器内置js引擎
                     2、独立安装js引擎：node js



     如何编写：4种方式
       1、直接在浏览器控制台（F12）,编写js脚本
       Console：控制台：专门编写和调试js程序的窗口
       eg:console.log("Hellow World!");
         console;特指控制台窗口
	 . : 的
	 log:console中提供的一个功能
	     功能接受有一个字符串参数，在控制台输出该字符串
	 字符串：一串字符的集合
	          字符串必须用引号包裹（单双引号都可以）

         程序中的关键字区分大小写！*
	 字符串中的字符，不区分大小写

	 2个按键：
	   多行程序：Shift+Enter
	   上下方向键：切换已执行过的代码————避免重复编写



       2、在网页中编写js脚本程序：3处
        1、<script>元素中
         直接编写在<script>中的js程序，随网页加载过程解释执行
          document:当前网页
	  write:写入功能，直接写入body元素中
	        不带换行
		write中的字符串必须符合html语法

	  强调：write换行：<br>

	 2、单独js文件保存js脚本程序：2步；
	    1、创建.js文件，保存js脚本程序
	    2、<script src="url"></script>引入外部js文件脚本程序：不需要预编译，边解释变执行
            3、元素的事件处理程序中编写--了解
	       不随网页加载过程执行
	       只有触发事件时，才执行
	       window:指当前的窗口
	       alert:弹出警告框


  如何调试：
      bug；程序中出现的一切错误
      debug:发现错误，解决错误
      js 程序出错：希望的交互效果没出来————F12-->console
       console:错误信息：3部分
                错误的类型：错误的原因  出错位置的链接

		出错的现象：出错位置同<script>下的程序:
		出错前的程序正常执行
		出错位置及以后的位置不再执行
		不同<script>下的程序继续执行

——————————————————————————————————————————————————————————————————————————————————————————————————
//------------------------------------------------01pm



***正课：
1、***变量
2、***数据类型

1、***变量
   what:内存中存储一个数据的存储空间，再起个名字
   when:程序中的数据都要先用变量保存，再处理
   如何使用变量：声明  赋值  取值
        声明：在内存中创建一个新变量
	如何声明：var 变量名=值;
	强调：仅声明未赋值的的变量，默认值为undefined
         命名规则： 1、不能数字开头
		    2、不能用保留字

		    3、*见名之义*
		    4、驼峰命名：首字母小写，之后每个单词首字母大写
		       比如：backgroundColor
		             listStyleType
			     studentName



	赋值：将一个数据存入变量中
	如何赋值：变量名=值
	=：专门表示将右边的值，存入左边的变量中保存
	对已有值得变量赋新值，新值会替换旧值
        强烈建议：声明同时初始化 赋值

	取值：从变量中取出数据，进行运算
	如何取值：在程序任何位置，只要使用变量名等效于直接使用变量中存储
 
    特殊情况：2种：
           1、为一个从未声明过的变量赋值：不会出错！
	      会自动创建同名变量，再保存数据
	   2、尝试从一个未声明过得变量中取值，会出错！
	       ReferebceError:未找到或未定义
	   
***声明提前：在程序正式执行前，都会将所有var声明的变量提前到开始位置，集中创建。***赋值留在原地***。



2、常量：一旦声明并初始化后，值不可改变的量！
   when:只要保存一旦创建，不可擅自改变的量时
     比如： 

   how：const 常量名=值;
        常量名全大写


3、***数据类型：
   what:内存中存储不同数据的存储格式
   js中数据类型：2大类
    1、原始类型：值保存在变量本地的数据类型
        五种：Number   专门保存数字的类型
	      String   专门保存字符串的类型
	      Boolean  专门保存真/假二选一的类型
	      underfined 只有一个值underfined
	      null 表示不指向任何地址
    2、引用类型：值不保存在变量本地的数据类型



    Number类型：专门保存数字的类型，不加引号
    when:要参与算数计算或比较大小的数据
      比如：价钱  年龄
    
    所占空间：64位2进制数保存
              64Bit=8bytes
    强调：数字所占空间和数值大小无关
          所有数字都占8字节:8bytes

	      1GB=1024MB
	      1MB=1024KB
	      1KB=1024bytes
	      1byte=8Bit
****舍入误差：因为计算机中无法精确表示1/10，导致计算中产生的误差。不可避免！
     解决：四舍五入   n.toFixed(2):将n按两位小数四舍五入



     String类型：专门保存一串字符的序列，必须带引号
     when:保存文字时，或保存仅用于显示的数字时
     比如：姓名  身份证号  手机号  QQ号
     所占空间：js的程序内存中的字符都是用unicode标识的
         unicode：对全球主要语言中的每个字符都编一个号
	 每个字母、标点：1字节:1bytes
	 每个汉字：2字节:2bytes
	 比如：”Hello马里奥“
	        11111 2 2 2=11个

***字符串内容一旦创建，不可改变！
    要想改变，只能创建新字符串，替换旧字符串

    +：如果参与+运算的值中包含字符串类型数据


  Boolean类型：只有两个值true/false
  when:如果表示二选一的值时，就用Boolean
==============================================================================================
Day02   
回顾：
1. 变量：声明(var) 赋值(=) 
         取值(使用变量名等效于使用变量中的值)
***声明提前：程序开始执行前，
             将所有var声明的变量提前到开始位置
             赋值留在原地
       console.log(a); //undefined
       var a=100;
       console.log(a); //100

***使用变量报错：尝试从*未声明*的变量中*取值*
***给未声明的变量赋值，*不会报错*！会自动创建同名变量

2. 数据类型：2大类
    原始类型：值保存在变量本地的数据类型
	5种：Number String Boolean undefined null
        Number：8bytes 舍入误差-->四舍五入
        String：每个英文字符 1byte
                每个汉字字符 2bytes
                一旦创建内容不可改变
        Boolean: true false
                    
    引用类型：值不保存在变量本地的数据类型

js中的变量 vs 数据库
   内存中     硬盘上的文件
   临时的     持久的
   客户端     服务器端只存一份

正课：
1. ***数据类型转换
2. ***运算符和表达式

1. ***数据类型转换：
    ***js是弱类型编程语言：3方面：
        1. 声明变量时，不用规定变量存储的数据类型
        2. 赋值时，动态决定变量的数据类型
           同一个变量，先后可保存不同类型的数据
        3. 运算时，js会根据需要，动态转换数据的类型

   2大类：
    1. 隐式转换：无需程序员干预，js自动完成的类型转换
	仅讨论+运算中的隐式转换：2句
        算数计算中，一切类型都隐式转为number类型，再计算
            比如："2"-->2   true/false-->1/0
        特例：+运算中，只要有一方是字符串，两数据都转为字符串，且+运算变为字符串拼接！

    表达式：由数据，变量和运算符组成的一个公式
            每个表达式默认都从左向右，两两计算
            *每个表达式有且仅有一个运算结果！*

    NaN：Not a Number-->说明运算中包含了无法转为数字的值
         不是数字 的 数字
         NaN和任何数据做计算，永远返回NaN
    typeof(x): 专门用于判断x的数据类型，返回数据类型名
        typeof(NaN): number

    隐式转换，仅影响表达式的运算结果，不影响变量中存储的实际值。

    2. 强制转换：程序员通过主动调用专门函数，执行转换
       1. 任意类型 to String: 2种：
          var str=x.toString();
          js中，一切数据都有toString方法
          var str=String(x);-->隐式转换
          何时使用：程序在需要时，自动调用
    ***2. 任意类型 to Number: 2种：
           任意类型 to Number: var n=Number(x);-->隐式

           String to Number: 2种：
		var n=parseInt(str);
                原理：从str开始位置逐个读取每个字符
                直到碰到第一个不是数字的字符时，停止读取
                自动忽略开头碰到的空格
           比如：var width="12px";
                     width+"2px"-->"12px2px"
                     Number(width)+Number("2px")-->NaN
                  parseInt(width)+parseInt("2px")
                  parseInt("12px")+parseInt("2px")
                            12               2    -->14
                   width=14+"px";
                 var money="$400"; NaN
                           "34.56"; 34
       
                var n=parseFloat(str);
                  原理和parseInt完全一致！
                  但是，parseFloat,只认第一个小数点
                  比如：parseFloat("34.56"); 34.56
                        parseFloat("34.56.78"); 34.56

     Number(x) vs parseInt(str)
	比如：Number("12px")-->NaN
              parseInt("12px")-->12
             string to Number-->parseInt
           
              Number(true)-->1
              parseInt(String(true))
              parseInt("true")-->NaN
             x to Number-->Number()

       3. 任意类型-->Boolean: 1种：
           var bool=Boolean(x);-->隐式转换
            ""  NaN  undefined null 0 --> false
            其余-->true

    课堂练习：
       输入框：var input=[window.]prompt("输入提示");
                         [window.]alert();
       ***凡是从页面上获得一切数据，都是字符串类型

2. ***运算符和表达式：
    程序：让计算机按照人的想法去执行任务
    运算符：程序中模拟人的思维运算或判断的符号

    运算符：算数运算符：+ - * /    %  ++ --
     %运算：取余数 6789%100-->89
            被除数/除数,不取商，而是取除不尽的余数部分
     何时使用：2大用途：
         1. 判断奇偶数：n%2-->1 奇数  否则 偶数 
         2. 限制一个运算的结果，不超过某个最大值（除数)
         
//------------------------------------------------02pm
正课：
运算符：
1. 算数运算符：++ --
2. 关系运算
3. 位运算——了解
4. 赋值运算
5. 三目运算

1. ***算数运算：仅++
    ++：将当前变量中的值递增1
    比如：n++; ++n; <==> n=n+1;
    何时使用：今后，只要对变量中的值递增1，还存回变量中
    3种情况：n++单独使用,前++和后++都一样
       ++运算参与到其他表达式中：
          前++(++n):将n中的值+1，然后返回*新值*
          后++(n++):将n中的值+1，然后返回*旧值*
    --：将当前变量中的值递减1
    比如：n-- <==>n=n-1;

2. ***关系运算：将两个值做比较：> < >= <= == !=
   只能返回两个值之一：如果成立，返回true；否则返回false
     隐式转换：将所有类型都转为number类型，再比较！
   特殊情况：3种：
     1. 两字符串做比较：依次PK每一位字符的unicode编号
                 只要有一位字符，分出大小，就不再比较
        比如："3">"10" -->true
              "Smith">"Scott" -->true
                "m"    "c"
                109     99
              "张东">"张无忌" -->false
               "东"    "无"
               19996   26080
     2. NaN: NaN和任何数据做大小或等于比较永远返回false
             NaN和任何数据做*不等于*比较，永远返回true
        isNaN(num):专门判断num是否是NaN
                   如果是NaN返回true，否则返回false
        When：今后只要判断一个数值是否是数字或能否被转为数字，都用isNaN。如果是数字,返回false！否则返回true

     3. undefined vs null
        undefined == null   true
        ===: 全等：数据类型要相同，再比较值是否相等
                  不带隐式转换
           何时使用：只要不希望关系运算中自动隐式转换时

3. ***逻辑运算：综合多个关系运算的结果得出最终结论
     隐式类型转换：自动将每个条件转为Boolean类型
     鄙视题：
        alert(4&&5);//?
        alert(4||5);//?
       返回值只能二选一：满足条件返回true，否则返回false
     3个：
     关系运算1&&关系运算2：
             而且
	两个条件必须都是true，才返回true，否则返回false
     关系运算1||关系运算2：
             或者
        只要有一个条件为true，则返回true
        只有两个条件都为false时，才返回false
     ！关系运算：颠倒关系运算的true/false结果

    ***短路逻辑：如果前一个条件已经可以得出结论，
                 则后续条件不再执行！
    作业：5_login.html：鄙视题

    ***利用短路逻辑：2种：
      1. 利用&&的短路逻辑：
        关系运算&&操作：只有满足关系运算时，才执“操作”
      2. 利用||的短路逻辑：
        关系运算||操作：如果前一个条件不满足，才执行后一个"操作"  

    作业：逻辑运算：课堂练习：2个问题
        问题1：如何判断一个字符是汉字：
             第一个汉字"一"-->"\u4e00"
             最后一个汉字"\u9fa5"

4. 位运算：2个
   左移：n<<m 将n的二进制，左移m位
        比如：1<<3  -->1*  2的3次方
   右移：n>>m 将n的二进制，右移m位
        比如：64>>3 -->64/ 2的3次方  ==> 8

5. 扩展赋值运算：5个：+=  -=   *=  /=  %=
     仅讨论+=: n+=2; ==>n=n+2
        将n中的值+2后，再保存回n中
     何时使用：今后只要对变量中的值进行累加时，都要用扩展赋值运算。

6. ***三目运算：根据不同的条件，多选*一*，返回不同的结果
   语法：条件1?值1:
         条件2?值2:
           ...?...:
             默认值;
   无论三目运算多么复杂，结果只能是一个值。

==============================================================================================
Day03
回顾：
1、隐式转换：
   算数计算中：一切都转为Number
                特例：+运算，碰到字符串，都转为字符串，拼接字符
   关系运算：一切都转为Number
                特例1：两字符串作比较，逐个Pk每个字符的unicode
		特例2：NaN 不等于任何数值
		       NaN > < =比较永远返回false
		       isNaN(num)--专门判断一个数值是否是NaN反着用：专门判断num是否是一个数字
		特例3：null==undefined-->true
		       null==undefined-->false
		       Number(null)=0
		       Number(undefined)=NaN

    逻辑运算：一切都转为Boolean

 
 2、强制转换：
   1、任意 to String:
         var x.toString();
	 var str=String(x);-->隐式转换
   2、任意 to Number:
         var num=Number(x);-->隐式转换

	 String to Number:
	 parseInt/Float(str);
   3、任意 to Boolean
      var bool=Boolean(x);
      ""NaN null undefined 0-->false

 3. 运算符：
   1. 算数运算：%  ++   --
      前++：将变量中的值+1，返回新值
      后++：将变量中的值+1，返回旧值

   2. 关系运算：> < >= <= != ==
   3. 逻辑运算：&&  ||   !
    	短路逻辑：
        根据条件判断是否执行某个操作：
         1. 条件&&操作：只有满足条件才执行“操作”
         2. 条件||操作：如果不满足条件，才执行“操作”
   4. 位运算： <<    >>
   5. 扩展赋值运算：+= -= *= /=
   6. 三元运算：
      条件1?值1:
      条件2?值2:
        ...?...:
         默认值;

+++++++++++++++++++++++++++++++++++++++++++++++

 正课：
 1、***函数
 2、全局函数--了解
 3、*分支结构


 1、***函数：封装一个专门任务的步骤清单的代码段，请一个任务名
    何时使用：只要定义一个专门的任务，都要封装一个函数

    使用函数：声明 定义和调用
    如何声明并定义一个函数：
       function 函数名（[参数变量列表]）{
          函数体：包含任务的步骤清单（代码段）
	  [return 返回值]
       }

    如何调用函数：[var 返回值]=函数名([参数值列表])
       函数只有调用时才执行！
       反复调用，就会反复执行相同操作！
    
    为什么定义函数：一次定义，反复使用！--代码重用
                    一次修改，处处生效


    函数的参数：专门接收传入函数内的数据的*变量*
    何时定义参数：如果一个参数必须某些数据才能正常执行时
                   参数可以让方法变的更灵活
    如何定义参数变量：function 函数名 (变量1，变量2...)
    如何传递参数值：调用时：函数名:(值1，值2...)
      强调：一般值的个数和顺序，应于声明时的参数列表一致


    返回值：方法调用后，返回的执行结果！--1个数据
    如何返回数据：函数体中：return要返回的数据
        强调：1、return单独使用，表示退出函数执行的意思
	      2、函数仅负责返回值，不负责保存返回值！
    如何获得返回值：调用时：var变量=函数名();

***变量作用域：一个变量的可用范围
     js中2种作用域：1、全局作用域：一个变量可以在程序的任何位置被访问
                2、函数作用域：一个变量仅能在函数调用时，内部被访问

     js中2中变量：
     1、全局变量：定义在全局作用域中的变量
         2种：1、直接在任何函数外声明的变量
	         全局变量都属于window--全局对象
	      	 2、无论在任何位置，为从未声明过的变量赋值时
	         自动在全局创建同名全局变量
     2、局部变量：定义在函数作用域中的变量
        2种： 1、在函数定义内部声明的变量
	      2、参数变量天生就是局部变量

函数其实是引用类型的对象
函数名其实是指向函数的变量


函数的定义和调用过程：
1、声明和定义函数时：
     window中创建了函数名变量
     window外创建了函数定义的对象——>封装函数的定义
     函数名变量中保存了指向函数对象的地址
2、调用时
     创建局部变量：2种
3、调用过程中，如果局部有，就不用全局的
                如果局部没有，才会用全局的
		如果全局也没有，则报错！
4、调用结束后，释放所有局部变量！
                全局变量还在

//------------------------------------------------03pm
正课：
1、***函数：*声明提前。*按值传递
2、全局函数--了解
3*分支结构


1、**函数：
   *声明提前：在程序执行前或函数被调用前
            将var声明的变量和function声明的函数，提前到当前作用域的顶部
	   强调：仅声明提前，赋值留在原地



   ***按值传递：js中无论是变量间赋值或使用变量传递参数时，都是将变量中的值，复制一个副本给对方！


 2、全局函数--了解
    what:ES标准中已经定义好的，开发者可直接调用的函数
          parseInt/Float(str)
	  isNaN(num)

	  BOM:
	  alert(str)不是
	  prompt(str)不是
  编码/解码:
     编码：将url中的非法字符，改为合法字符表示
       http://..../s?word=%E5%BC%A0
                             张
                         utf-8格式编码
                           汉字占3字节
       url中不允许出现多字节字符！
       解决：将url中的多字节，变为单字节
       url中不允许参数值中出现保留字符：比如: /
       http://tmooc.cn -->http%3A%2f%2ftmooc
       解决：encodeURIComponent
     解码：将url中的非法字符编码后的内容，恢复成原文
             decodeURIComponent

   eval: 计算字符串格式的表达式的值
         或执行字符串格式的js语句


3、*分支结构：
    程序结构3大类
         顺序：程序默认都是从上向下逐行执行
	 分支：根据条件判断的结果，有选择的执行不同代码段
	 循环：程序可以反复执行统一代码段，到达临界时退出

   需求：InputProcessOutput
         Input:单价(price) 数量(count) 收款金额(money)
	 Output:总价(total) 找零(change)
	 Process:
	     总价=单价*数量
	     如果总价>=500，则打八折
	     找零=收款-总价

   分支结构:3种：
       1、if结构：1件事  满足条件就执行，否则不执行
          语法：if(条件){
		满足条件才执行的代码段
	  }
       2、if...else...结构：2件事 满足条件执行if中的代码段
                                   不满足条件执行else中的代码段

	   语法：if(条件){
		        满足条件执行if中的代码段
	         }
	         else{
			不满足条件执行else中的代码段
		 }


       3、else lf结构：多件事，根据条件，多选一执行！
           语法：
	   lf(条件1){
		满足条件1才执行的代码段1
	   }
	   else lf(条件2){
		满足条件2才执行的代码段2
	   }
	   else lf(条件3){
		满足条件2才执行的代码段3
	   }.。。。。。。。

	   万一之前所有条件都不满足，才执行默认代码段
	   如果程序已经引入后一个条件判断，就已经暗示前一个条件肯定不满足


	   分支结构 vs 三目/短路
     如果只是返回值-->三目/短路
     如果操作复杂-->分支结构

   作业：PPT 14页 2题
   作业：使用if...else if结构实现可莱托指数

==============================================================================================
Day04
回顾：作业

正课：
1. *分支结构：switch case
2. *循环结构：3种

1. switch case结构：都是根据不同条件执行不同的代码段
          用switch中的表达式的值和case中的值做*全等*比较
   语法：switch (表达式){
	     case 值1:
		代码段1;
             case 值2:
                代码段2;
             ...
                ...
             [default:
		默认代码段;
	     ]
         }

    break: 停止当前结构的执行，并跳出当前结构

    switch vs else if:
      switch: 条件是全等比较时，首选switch case
      else if: 除全等比较外，希望灵活定义条件时

2. 循环结构：让程序反复执行一段代码段
             只有达到临界条件时，停止循环
    3要素：
      1. 循环条件：继续循环的条件：圈数<3
      2. 循环变量：在循环条件中，用作比较的变量：圈数
          循环变量一般会向着不满足循环条件的趋势不断变化
          比如：圈数：每转一圈+1
      3. 循环体：反复执行的代码段


    3种：
    1. while循环：
      语法：var 循环变量=初值;
            while(循环条件){
 	        循环体;
                迭代变化循环变量;
            }

      退出循环：2种方式：
        1. 自然退出：不满足循环条件时，自动退出循环
        2. 手动退出：程序员在循环体中用break强行退出循环

    2. do while循环：
      语法：var 循环变量=初值;
            do{
 	        循环体;
                迭代变化循环变量;
            }while(循环条件);

     差别：当第一次条件满足时，while和do while完全一样！
           当第一次条件就不满足时，
               do while:至少会执行一次
               while: 一次都不执行！
     何时使用do while代替while？
       只要希望哪怕第一次条件都不满足，至少也能执行一次

   *js中没有块级作用域：分支/循环结构中声明的变量，出了结构，照样使用！*

   //------------------------------------------------04pm
	正课：
	1. *for循环：

	   语法:
	for(var 循环变量=初值;循环条件;迭代变化循环变量){
	    循环体;
	}
	   何时使用：只要循环变量的变化规律固定！
	             优先选择for循环

	   continue: 结束本轮循环，继续下一轮循环
	           continue一般都可以使用否定条件代替！

==============================================================================================
Day05

回顾：
1. 分支：
   短路逻辑：
     条件&&操作：1件事，满足条件就做，否则不做
       只限于操作简单的情况下
     值1||值2：如果值1有效，就返回值1，否则返回值2
   三目运算：多个值，按条件判断，多选一
     条件1?值1:
     条件2?值2:
       ...?...
        默认值;
   if...else if结构：当操作复杂时，就用if结构。3种：
    if(条件){代码段}：1件事，满足条件就做，否则不做
    if(条件){：2件事，满足条件做代码段1，否则做代码段2
        代码段1
    }else{
  	代码段2
    }
    if(条件1){：多件事，根据条件判断，多选一执行
        代码段1
    }else if(条件2){
 	代码段2
    }...
    }[else{
	默认代码段
    }]

   switch case：如果条件是全等比较时，就用switch case
     switch(表达式){
	case 值1:
           代码段1;
           [break;]
        case 值2:
           代码段2;
           [break;]
        [default:
	   默认代码段]
     }
2. 循环：3种：
   while: 循环变量的变化规律不确定时
do-while: 如果第一条件就不满足，也希望至少能执行一次时
   for: 循环变量的变化规律固定时

   三要素：
   1. 循环条件：继续循环的条件
   2. 循环变量：循环条件中用作比较的变量
          从几开始，每次增/减几，到几结束
   3. 循环体：循环反复执行的代码段
        循环体中都会向着不满足循环条件的趋势改变循环变量

正课：
1. ***数组：

程序=数据结构+算法
     好的数据结构，可极大提高程序的执行效率
     相关的多个数据应集中存储，集中管理
     分类和排序

   数组：一组连续的变量组成的集合——统一起一个名字
         批量管理多个数据

   如何使用：创建    赋值     取值
    1. 创建：4种：
       1. var 变量名=[];-->创建一个空数组对象
       2. var 变量名=[值1,值2,...]-->创建数组同时，为数组指定初始元素(数组中每个值)
        数组是引用类型的对象
        变量中保存了数组对象的地址值，也成引用了数组对象

       3. var arr=new Array();-->创建一个空数组对象
         new：创建一个新对象，并返回新对象地址
         Array：js中的数组类型
         new Array()-->创建一个数组类型的新对象，并返回新对象的地址。
       4. var arr=new Array(n);-->创建n个元素的数组
                  new Array(值1,值2,...)

    找到数组：使用变量等效于直接使用变量引用的数组对象
    数组对象中，每个元素都有一个下标：每个元素的位置号
        下标从0开始，到元素个数-1结束
    使用数组中的每个元素：
	数组变量[i]-->获得i位置元素中的值
        *数组变量[i]的用法和普通变量完全一样！*
    2. 赋值：数组变量[i]=新值;
    3. 取值: 数组变量[i]

    null和undefined:
      undefined: 是所有没有值得变量的默认值，自动赋值
      报错undefined:不存在  提示undefined:存在但没有值
      null: 主动释放一个变量引用的对象
        何时使用null：
	 当使用完一个较大的对象时，主动释放对象总是好的习惯

    垃圾回收器：专门释放对象内存的一个程序
                在底层，后台，伴随当前程序同时运行
                引擎会定时自动调用垃圾回收期
                总有一个对象不再被任何变量引用时，才释放

    js数组 vs 其他语言的数组：
    *js数组下标越界不会出错！*
      为不存在的位置赋值：不会出错！会自动创建指定下标的新元素。
      从不存在的位置取值：不会出错！也不会增加新元素
                          而是返回undefined
//------------------------------------------------05pm

正课：
1. *.length属性
2. *数组遍历
3. *关联数组
4. ***冒泡排序——手写*
5. *数组API

1. 数组是对象：封装了一组数据，并提供了对数据的操作方法
   .length属性：获得数组中的元素个数! =实际的元素个数
   何时使用:3种：
    arr[arr.length-1]: 获得任意长度数组中的最后一个元素
    arr[arr.length]=新值: 向数组末尾追加一个新元素
    改小length的值，可删除末尾元素
   
2. 数组遍历：从下标0位置开始，依次取出每个元素，反复执行相同的操作。
      三要素:
      1. 循环条件：下标i<arr.length
      2. 循环变量：下标i, 
		从0开始，每次增1，到arr.length-1结束
      3. 循环体：xxx


3. 关联数组：可以自己定义下标名称的数组
   索引数组：自动生成下标的数组都是索引数组
   为什么：["范冰冰", 91, 65, 95]
             sname   shx yuw eng
   如何创建关联数组: var fbb=[];
                           key      value 对儿
                     fbb["sname"]="范冰冰";
                     fbb["shx"]=91;
                        
   如何访问关联数组中的元素：fbb["sname"]

   关联数组中的.length属性失效！

   关联(hash)数组: 下标是不能重复的
          优势：利用Hash算法，精确定位某个下标的位置
                不用遍历
   索引数组：缺：下标自动分配，无意义
                 要想按内容查找元素，只能从头开始遍历！

   遍历关联数组：依次遍历arr中每个元素，
	         将当前元素的下标存入key中
       for(var key in arr){
	    key，仅得到当前元素的下标
            arr[key]，得到当前元素的值！
       }

4. ***冒泡排序：——手写

5. *数组API：数组=数据+操作数据的API
    1. 数组 to String:2种：
        var str=arr.toString();
		-->输出数组中的内容，每个元素用逗号分隔
                -->自动调用
        var str=arr.join("连接符")
                -->输出数组中的内容,自定义元素间连接符
        何时使用：2种固定套路
           1. 将字符组成单词：arr.join("")
           2. 将单词组成句子：arr.join(" ")

    2. 拼接和截取：*API无法直接修改原对象，而返回新对象*
    拼接：var newArr=arr.concat(另一个数组,值1,值2...)
    复制子数组：var subArr=arr.slice(starti,endi+1);
                                      含头不含尾

    3. splice: 删除   插入    替换
       1. 删除：直接修改原数组对象
	[var deleted=]arr.splice(starti,删除个数)
         返回本次删除元素组成的数组
       2. 插入：
        arr.splice(starti,0,新值1,...)
       3. 替换：
        arr.splice(starti,删除个数,新值1,...)
    4. arr.reverse(); 颠倒数组中所有元素

==============================================================================================
Day06

回顾：
1. API: 应用程序编程接口
        已经实现的，现成的对象和方法。——提高开发效率

2. 数组API：
   1. arr to String:
      var str=arr.toString()-->自动，逗号分隔
      var str=arr.join("连接符")-->自定义连接符
           固定套路：1. 将字符拼接为单词: arr.join("")
                     2. 将单词拼接为句子: arr.join(" ")
   *优化：问题：频繁字符串拼接，造成内存浪费*
      解决：先将要拼接的字符串放入数组
            最后，arr.join("")
      var arr=["a"];
      arr[arr.length]="b";//1个arr 2个str
      arr[arr.length]="c";//1个arr 3个str
      arr[arr.length]="d";//1个arr 4个str
      [ "a" , "b" , "c" , "d"]
      arr.join("")

   2. 拼接和截取：原对象保持不变，返回新对象
      var newArr=arr.concat(新值1,另一个数组,新值2...)
      var subArr=arr.slice(starti[,endi+1]);
      第二个参数可省略，如果省略表示从start一直取到结尾
      两个参数都可以取负值，就近使用下标
      含头不含尾
   3. arr.splice(): 删除  插入  替换
   4. arr.reverse();

正课：
1. ***数组API
    ***数组排序
    *栈和队列
2. *二维数组
3. ***String

1. 数组API：
   1. 数组排序：arr.sort();
        问题：默认将所有元素转为字符串升序排列
      ***比较器函数：专门比较任意两值大小的函数
          2特点：1. 2个参数，分别表示要比较的任意两值
                 2. 无论比较逻辑是什么，都要返回一个数字

      ***函数对象作为参数：
         js中函数本质是一个对象
         函数名本质是指向函数对象的变量

      如何自定义sort方法的排序？
      arr.sort(比较器函数)

      *颠倒比较器结果的正负，可改升序为降序排列*

      //------------------------------------------------06pm

正课：
1. *栈和队列
2. *二维数组
3. ***String

1. *栈和队列：js中没有真正的栈和队列的类型
              一切都是用数组对象模拟的
   栈：只能从一端进出的数组，另一端封闭
       FILO
   何时使用：今后只要仅希望数组只能从一端进出时
   如何使用：2种情况：
     1. 末尾出入栈：已入栈元素的下标不再改变
        入栈: arr.push(新值1,...)
        出站: var last=arr.pop()

     2. 开头出入栈：每次入栈新元素时，已入栈元素的位置都会向后顺移。
        入栈：arr.unshift(新值1,...);
        出站：var first=arr.shift();

   队列：只允许从末尾进入数组，必须从开头出数组
       FIFO
      结尾入队列：arr.push();
      开头出队列：var first=arr.shift();

2. *二维数组：数组中的元素，又引用了另一个子数组对象
    何时使用二维数组：2种：
       1. 只要保存横行竖列的二维数据
       2. 保存上下级关系的数据时

    如何创建二维数组：2种：
       1. 先创建空数组，再赋值:
          var arr=[];
          arr[0]=["石家庄","保定","唐山"];
	  arr[1]=["德州","济南","烟台"];
       2. 创建数组时，同时初始化子数组：     
          var data=[
	      [0,2,2,4],
              [2,4,4,8],
              [16,32,16,8],
              [4,2,128,4]
          ];

    如何访问二维数组中的数据：arr[行下标][列下标]
        比如：data中第2行，第3个元素
              data[1][2]
    强调：二维数组中，行下标不能越界！
          console.log(data[1][5]); //undefined
          console.log(data[5][1]); //
                  //undefined[1]

　　遍历二维数组：
	固定套路：外层循环遍历行，内存循环遍历列
        var arr=[[...],[...]...]
	for(var r=0;r<arr.length;r++){
	    for(var c=0;c<arr[r].length;c++){
     		
            }
        }
3.***String: 字符串：
    什么是字符串：多个字符组成的一个*只读*的集合(数组)
    凡是数组对象中，不修改原对象的API，字符串都能用！
    比如：.length属性：字符个数；都可用[i]访问每个字符
    比如：slice, indexOf
    
    凡是数组对象中，直接修改原对象的API，字符串都不能用！
    比如：push,  sort , splice

    内置对象：ES标准中已经定义好的，
             由浏览器厂商已经实现的对象
    11个：String Number Boolean
    Array Date Math RegExp
    Error
    Function Object
    Global（全局）

    包装类型：临时封装原始类型数据，
             提供对原始类型数据的操作方法
    3种：String Number     Boolean(不能new)
    何时使用包装类型：自动使用
    为什么使用包装类型？原始类型的数据本来没有任何方法
          当程序中使用原始类型调用方法时，程序会自动创建包装类型对象封装该数据。
          函数调用完，包装类型自动释放

    String API：*所有API都无法直接修改原字符串*
    1. 转义字符：当字符串的内容和程序的特殊符号冲突时
           或字符串中包含功能字符时，都用\转化字符的意义
       \n：换行  \t: 一次缩进Tab键
    2. 大小写转换：将字符串中所有字符都统一转为大写或小写
       何时使用：不区分大小写时
         比如：用户名  验证码    电子邮件
       转大写:str=str.toUpperCase();
       转小写:str=str.toLowerCase();
    3. 获取指定位置的字符：3种：
       1. str[i]
       2. str.charAt(i)
       3. str.charCodeAt(i)-->获得字符的unicode号
    4. 查找关键字的位置：2种：
       1. var i=str.indexOf(kword[,starti]);
            从左向右，查找kword首字符在字符串中的下标
            如果没找到，返回-1
          starti：从starti位置开始向后查找下一个
            如果省略starti，默认从0开始找
       2. var i=str.lastIndexOf(kword[,starti])
            从starti位置开始，向左找！下一个kword
             
     作业：day01-->素材-->preview
                             -->Homework_string_mario